# External Secrets Operator Integration for SpiceDB
# This example demonstrates how to use External Secrets Operator (ESO) to manage
# SpiceDB datastore credentials securely without storing them in Helm values.
#
# Prerequisites:
# 1. External Secrets Operator installed in the cluster
#    kubectl apply -f https://raw.githubusercontent.com/external-secrets/external-secrets/main/deploy/crds/bundle.yaml
#    helm install external-secrets external-secrets/external-secrets -n external-secrets-system --create-namespace
#
# 2. A SecretStore or ClusterSecretStore configured for your backend
#    (AWS Secrets Manager, GCP Secret Manager, Azure Key Vault, HashiCorp Vault, etc.)
#
# 3. Credentials stored in your secret backend with the following structure:
#    - datastore-uri: Complete PostgreSQL connection string
#    - preshared-key: SpiceDB preshared key for internal authentication
#
# Usage:
#   1. Create the SecretStore/ClusterSecretStore (see examples below)
#   2. Create the ExternalSecret resource (see example below)
#   3. Deploy SpiceDB with the Helm chart referencing the external secret
#
# Example deployment:
#   kubectl apply -f examples/postgres-external-secrets.yaml
#   helm install spicedb ./charts/spicedb -f examples/postgres-external-secrets.yaml

---
# Example 1: ClusterSecretStore for AWS Secrets Manager
# This allows ExternalSecrets across all namespaces to access AWS Secrets Manager
apiVersion: external-secrets.io/v1beta1
kind: ClusterSecretStore
metadata:
  name: aws-secrets-manager
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-east-1
      # Authentication via IAM Role (recommended for EKS with IRSA)
      auth:
        jwt:
          serviceAccountRef:
            name: external-secrets-sa
            namespace: external-secrets-system

---
# Example 2: SecretStore for GCP Secret Manager (namespace-scoped)
# apiVersion: external-secrets.io/v1beta1
# kind: SecretStore
# metadata:
#   name: gcp-secret-manager
#   namespace: default
# spec:
#   provider:
#     gcpsm:
#       projectID: "my-gcp-project"
#       # Authentication via Workload Identity (recommended for GKE)
#       auth:
#         workloadIdentity:
#           clusterLocation: us-central1
#           clusterName: my-gke-cluster
#           serviceAccountRef:
#             name: external-secrets-sa

---
# Example 3: SecretStore for HashiCorp Vault
# apiVersion: external-secrets.io/v1beta1
# kind: SecretStore
# metadata:
#   name: vault-backend
#   namespace: default
# spec:
#   provider:
#     vault:
#       server: "https://vault.example.com"
#       path: "secret"
#       version: "v2"
#       auth:
#         kubernetes:
#           mountPath: "kubernetes"
#           role: "spicedb-role"
#           serviceAccountRef:
#             name: spicedb

---
# ExternalSecret Resource
# This fetches credentials from your secret backend and creates a Kubernetes Secret
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: spicedb-datastore-credentials
  namespace: default
spec:
  # Refresh interval - how often to sync from external secret backend
  refreshInterval: 1h

  # Reference to the SecretStore or ClusterSecretStore
  secretStoreRef:
    name: aws-secrets-manager
    kind: ClusterSecretStore

  # Target secret that will be created
  target:
    name: spicedb-datastore-secret
    creationPolicy: Owner

  # Data to fetch from the secret backend
  data:
    # Option 1: Fetch the complete connection string
    - secretKey: datastore-uri
      remoteRef:
        key: spicedb/production/postgres
        property: datastore-uri

    # Option 2: Fetch individual connection parameters and construct the URI
    # Note: If using this approach, you'll need a template to construct the URI
    # - secretKey: db-host
    #   remoteRef:
    #     key: spicedb/production/postgres
    #     property: host
    # - secretKey: db-password
    #   remoteRef:
    #     key: spicedb/production/postgres
    #     property: password

    # SpiceDB preshared key for internal authentication
    - secretKey: preshared-key
      remoteRef:
        key: spicedb/production/postgres
        property: preshared-key

---
# Alternative: Using dataFrom to fetch all keys from a secret
# apiVersion: external-secrets.io/v1beta1
# kind: ExternalSecret
# metadata:
#   name: spicedb-datastore-credentials
#   namespace: default
# spec:
#   refreshInterval: 1h
#   secretStoreRef:
#     name: aws-secrets-manager
#     kind: ClusterSecretStore
#   target:
#     name: spicedb-datastore-secret
#     creationPolicy: Owner
#   dataFrom:
#     - extract:
#         key: spicedb/production/credentials

---
# Helm values for SpiceDB chart using the external secret
# Save this section to a separate file or use inline with -f flag

# SpiceDB Configuration with External Secrets
config:
  # Set datastore engine to PostgreSQL
  datastoreEngine: postgres

  # Reference the secret created by ExternalSecret
  # This tells the chart to use the external secret instead of creating one
  existingSecret: spicedb-datastore-secret

  # Log level
  logLevel: info

  # Note: datastore connection parameters are not needed here
  # because the complete connection string is provided via existingSecret

# High availability configuration
replicaCount: 3

# Production resource limits
resources:
  limits:
    cpu: 2000m
    memory: 2Gi
  requests:
    cpu: 500m
    memory: 512Mi

# Security best practices
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  readOnlyRootFilesystem: true
  capabilities:
    drop:
    - ALL

podSecurityContext:
  fsGroup: 1000
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault

# Pod disruption budget for high availability
podDisruptionBudget:
  enabled: true
  minAvailable: 2

# Pod annotations for monitoring
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "9090"

---
# How to store secrets in your backend (examples)

# AWS Secrets Manager (using AWS CLI):
# aws secretsmanager create-secret \
#   --name spicedb/production/postgres \
#   --secret-string '{
#     "datastore-uri": "postgresql://spicedb:SecurePassword123@postgres.database.svc.cluster.local:5432/spicedb_production?sslmode=require",
#     "preshared-key": "randomly-generated-32-char-key-here"
#   }'

# GCP Secret Manager (using gcloud):
# echo -n '{"datastore-uri": "postgresql://...", "preshared-key": "..."}' | \
#   gcloud secrets create spicedb-production-postgres \
#   --data-file=- \
#   --replication-policy="automatic"

# HashiCorp Vault (using vault CLI):
# vault kv put secret/spicedb/production/postgres \
#   datastore-uri="postgresql://spicedb:SecurePassword123@postgres:5432/spicedb?sslmode=require" \
#   preshared-key="randomly-generated-32-char-key-here"

---
# Security Best Practices:

# 1. Credential Rotation:
#    - Use your secret backend's rotation features
#    - External Secrets Operator will automatically sync rotated credentials
#    - Set appropriate refreshInterval (e.g., 1h, 15m)
#    - Consider using shorter TTLs for highly sensitive environments

# 2. Access Control:
#    - Use IAM roles/policies to restrict access to secrets
#    - Follow principle of least privilege
#    - Use separate secrets for different environments (dev/staging/prod)

# 3. Audit Logging:
#    - Enable audit logs in your secret backend
#    - Monitor access to sensitive credentials
#    - Set up alerts for unusual access patterns

# 4. Secret Versioning:
#    - Use versioned secrets in your backend
#    - Pin to specific versions for critical deployments
#    - Test credential rotation in non-production environments first

# 5. Network Security:
#    - Ensure TLS/SSL is enabled for database connections (sslmode=require or verify-full)
#    - Use private endpoints for database access when available
#    - Implement network policies to restrict pod-to-pod communication

# 6. Monitoring:
#    - Monitor ExternalSecret sync status
#    - Set up alerts for sync failures
#    - Track secret age and rotation compliance

---
# Troubleshooting:

# Check ExternalSecret status:
# kubectl describe externalsecret spicedb-datastore-credentials

# Check if the secret was created:
# kubectl get secret spicedb-datastore-secret

# View ExternalSecret events:
# kubectl get events --field-selector involvedObject.name=spicedb-datastore-credentials

# Check External Secrets Operator logs:
# kubectl logs -n external-secrets-system -l app.kubernetes.io/name=external-secrets

# Verify SecretStore connectivity:
# kubectl describe secretstore aws-secrets-manager
# kubectl describe clustersecretstore aws-secrets-manager
