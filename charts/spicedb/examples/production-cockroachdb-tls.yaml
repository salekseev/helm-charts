# Production CockroachDB Configuration with Full TLS
# This example demonstrates a production-ready deployment with:
# - CockroachDB datastore with mTLS
# - Full TLS configuration for all SpiceDB endpoints (gRPC, HTTP, dispatch, datastore)
# - High availability with 5 replicas
# - Production-ready resource limits and security settings
#
# Prerequisites:
# - CockroachDB cluster accessible from the Kubernetes cluster
# - Database and user created with appropriate permissions
# - TLS certificates for all endpoints (can be managed by cert-manager)
# - See examples/cert-manager-integration.yaml for automated certificate management
#
# Required Secrets (example names, adjust as needed):
# - spicedb-grpc-tls: TLS certificate for gRPC API endpoint
# - spicedb-http-tls: TLS certificate for HTTP/dashboard endpoint
# - spicedb-dispatch-tls: mTLS certificate for internal cluster communication
# - spicedb-datastore-tls: mTLS certificate for CockroachDB connection
#
# Usage:
#   # Create secrets first (manually or via cert-manager)
#   kubectl create secret tls spicedb-grpc-tls \
#     --cert=grpc-tls.crt --key=grpc-tls.key
#
#   # Install the chart with this configuration
#   helm install spicedb ./charts/spicedb -f examples/production-cockroachdb-tls.yaml

# High availability configuration with 5 replicas for distributed consistency
replicaCount: 5

image:
  repository: authzed/spicedb
  pullPolicy: IfNotPresent
  # Use a specific stable version in production
  tag: "v1.39.0"

# Enable TLS for all endpoints
tls:
  # Master switch to enable TLS features - must be true for any TLS configuration
  enabled: true

  # gRPC endpoint TLS configuration
  # This secures the primary SpiceDB API used by client applications
  # Client applications will need to connect using grpcs:// protocol
  grpc:
    # Secret containing the gRPC server certificate and key
    # Required keys: tls.crt, tls.key
    # Optional: ca.crt (if requiring client certificate verification)
    secretName: "spicedb-grpc-tls"

    # Certificate paths (defaults shown, usually no need to change)
    certPath: /etc/spicedb/tls/grpc/tls.crt
    keyPath: /etc/spicedb/tls/grpc/tls.key
    caPath: /etc/spicedb/tls/grpc/ca.crt

  # HTTP endpoint TLS configuration
  # This secures the SpiceDB dashboard and metrics endpoint
  # Access via https:// protocol
  http:
    # Secret containing the HTTP server certificate and key
    # Required keys: tls.crt, tls.key
    # Can reuse grpc secret if certificate includes HTTP service names
    secretName: "spicedb-http-tls"

    # Certificate paths (defaults shown, usually no need to change)
    certPath: /etc/spicedb/tls/http/tls.crt
    keyPath: /etc/spicedb/tls/http/tls.key

  # Dispatch cluster TLS configuration (mTLS)
  # This secures internal pod-to-pod communication within the SpiceDB cluster
  # STRONGLY RECOMMENDED for production to prevent unauthorized nodes from joining
  # Uses mutual TLS (mTLS) - both client and server verify each other
  dispatch:
    # Secret containing the dispatch mTLS certificate, key, and CA
    # Required keys: tls.crt, tls.key, ca.crt
    # All SpiceDB pods must share the same CA and have certificates signed by it
    secretName: "spicedb-dispatch-tls"

    # Certificate paths (defaults shown, usually no need to change)
    certPath: /etc/spicedb/tls/dispatch/tls.crt
    keyPath: /etc/spicedb/tls/dispatch/tls.key
    caPath: /etc/spicedb/tls/dispatch/ca.crt

  # Datastore TLS configuration
  # This secures the connection between SpiceDB and CockroachDB
  # CockroachDB requires mTLS by default in production deployments
  datastore:
    # Secret containing the datastore client certificate, key, and CA
    # Required keys: ca.crt (to verify CockroachDB server)
    # For mTLS: tls.crt, tls.key (client certificate for authentication)
    secretName: "spicedb-datastore-tls"

    # CA certificate path (to verify CockroachDB server certificate)
    # This path must match config.datastore.sslRootCert below
    caPath: /etc/spicedb/tls/datastore/ca.crt

# CockroachDB datastore configuration
config:
  # Set datastore engine to CockroachDB
  datastoreEngine: cockroachdb

  # Log level for production monitoring
  logLevel: info

  # Recommended: Use an external secret for database credentials
  # This keeps sensitive data out of Helm values
  # existingSecret: "spicedb-cockroachdb-credentials"

  # Datastore connection parameters
  datastore:
    # CockroachDB server hostname (use service name for in-cluster CockroachDB)
    hostname: "cockroachdb-public.database.svc.cluster.local"

    # CockroachDB default SQL port
    port: 26257

    # Database username
    username: "spicedb"

    # Database password (only if not using existingSecret)
    # In production, prefer using existingSecret instead
    password: "CHANGE_ME_INSECURE"

    # Database name
    database: "spicedb"

    # SSL mode for encrypted connections
    # CockroachDB requires verify-full for production security
    # This enforces both encryption and certificate verification
    sslMode: "verify-full"

    # SSL certificate paths for CockroachDB connection
    # These paths must match the paths configured in tls.datastore above
    # CockroachDB requires:
    #   - sslRootCert: CA certificate to verify the CockroachDB server
    #   - sslCert: Client certificate for mTLS authentication
    #   - sslKey: Client private key for mTLS authentication
    sslRootCert: "/etc/spicedb/tls/datastore/ca.crt"
    sslCert: "/etc/spicedb/tls/datastore/tls.crt"
    sslKey: "/etc/spicedb/tls/datastore/tls.key"

# Production resource limits for CockroachDB workloads
# CockroachDB tends to be more resource-intensive due to distributed nature
resources:
  limits:
    cpu: 4000m
    memory: 4Gi
  requests:
    cpu: 1000m
    memory: 1Gi

# Security context for container
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  readOnlyRootFilesystem: true
  capabilities:
    drop:
    - ALL

# Pod security context
podSecurityContext:
  fsGroup: 1000
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault

# Pod disruption budget for high availability
# Ensures at least 3 pods are always available during updates
podDisruptionBudget:
  enabled: true
  minAvailable: 3

# Horizontal Pod Autoscaler (optional)
# Uncomment to enable automatic scaling based on CPU/memory
# autoscaling:
#   enabled: true
#   minReplicas: 5
#   maxReplicas: 15
#   targetCPUUtilizationPercentage: 70
#   targetMemoryUtilizationPercentage: 75

# Node selector for scheduling pods on specific nodes
# Uncomment and adjust as needed
# nodeSelector:
#   workload-type: spicedb
#   disk-type: ssd

# Tolerations for pod scheduling
# Uncomment if using dedicated nodes with taints
# tolerations:
# - key: "dedicated"
#   operator: "Equal"
#   value: "spicedb"
#   effect: "NoSchedule"

# Anti-affinity rules to spread pods across nodes and zones
affinity:
  podAntiAffinity:
    # Hard requirement: don't schedule multiple pods on the same node
    requiredDuringSchedulingIgnoredDuringExecution:
    - labelSelector:
        matchExpressions:
        - key: app.kubernetes.io/name
          operator: In
          values:
          - spicedb
      topologyKey: kubernetes.io/hostname

# Topology spread constraints for zone distribution
# Ensures pods are distributed across availability zones
topologySpreadConstraints:
- maxSkew: 1
  topologyKey: topology.kubernetes.io/zone
  whenUnsatisfiable: DoNotSchedule
  labelSelector:
    matchLabels:
      app.kubernetes.io/name: spicedb

# Service configuration
service:
  type: ClusterIP
  grpcPort: 50051
  httpPort: 8443
  metricsPort: 9090
  dispatchPort: 50053

# Pod annotations for monitoring integration
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "9090"
  prometheus.io/path: "/metrics"

# Labels for organization
podLabels:
  environment: production
  team: platform
  datastore: cockroachdb
  tls: enabled

# Production Notes:
#
# 1. TLS Endpoints Overview:
#    - gRPC: Client application API (most critical for production)
#    - HTTP: Dashboard and metrics (less critical, but recommended)
#    - Dispatch: Inter-pod communication (critical for multi-replica security)
#    - Datastore: Database connection (required by CockroachDB)
#
# 2. Certificate Management:
#    - Use cert-manager for automated certificate lifecycle management
#    - See examples/cert-manager-integration.yaml for complete setup
#    - Ensure certificates are renewed before expiration (cert-manager handles this)
#
# 3. Security Best Practices:
#    - Use verify-full SSL mode for CockroachDB connections
#    - Enable dispatch mTLS to prevent unauthorized pods from joining cluster
#    - Rotate certificates regularly (cert-manager automates this)
#    - Monitor certificate expiration dates
#
# 4. Performance Considerations:
#    - TLS adds ~5-10% CPU overhead - adjust resource limits accordingly
#    - Use SSD storage for CockroachDB to offset encryption overhead
#    - Monitor connection pool settings and adjust based on workload
#
# 5. Troubleshooting:
#    - Check certificate expiration: kubectl get certificate -n <namespace>
#    - Verify secret contents: kubectl get secret <name> -o yaml
#    - View SpiceDB logs: kubectl logs -l app.kubernetes.io/name=spicedb
#    - Test gRPC TLS: grpcurl -cert client.crt -key client.key <host>:50051 list
#
# 6. Migration from Non-TLS:
#    - Cannot enable TLS on existing deployment without downtime
#    - Plan maintenance window for TLS enablement
#    - Test in staging environment first
#    - Update all client applications to use TLS connections
